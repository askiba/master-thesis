\chapter{Proponowane rozwi±zanie}
\label{cha:rozwiazanie}

W rozdziale tym przedstawiono informacje .

%---------------------------------------------------------------------------

\section{Model narciarza i ¶rodowiska}
\label{sec:model}

W zaproponowanym rozwi±zaniu trzeba by³a podj±æ pewne decyzje odno¶nie reprezentacji ¶rodowiska oraz narciarza.
Zosta³o przyjête, ¿e stok traktowany jest jako p³aszczyzna, która jest nachylona pod okre¶lonym przez sta³± $\alpha$ k±tem do powierzchni ziemi. Za³o¿enie co do p³askiej powierzchni jest tylko ograniczeniem przyjêtym do testów. Umo¿liwia to ³atwiejsz± analizê wyników niezaburzonych zmianami nachylenia terenu. Jednak stworzony program mo¿e zostaæ zmodyfikowany tak, aby zamodelowaæ bardziej skomplikowan± powierzchniê. 
Narciarz traktowany jest jako punkt materialny o masie m. 
%---------------------------------------------------------------------------

\section{Opis matematyczny modelu}
\label{sec:matematycznyModel}

m - masa\\
g - wspó³czynnik grawitacji\\
$\alpha$ - k±t nachylenia powierzchni stoku do powierzchni ziemi\\

Si³a grawitacji dzia³aj±ca na obiekt o masie m:\\
\begin{equation}
Q = mg
\end{equation}

Si³a ta mo¿e zostaæ roz³o¿ona na dwie si³y sk³adowe wzglêdem powierzchni stoku. Narciarz poruszaj±cy siê w dó³ stoku przypomina klasyczny przyk³ad punktu materialnego staczaj±cego siê po równi pochy³ej.\\
Sk³adowa si³y grawitacji równoleg³a do powierzchni stoku:\\
\begin{equation}
Q_a = mg\sin\alpha
\end{equation}

jest to si³a ¶ci±gaj±ca narciarza w dó³ stoku.

Sk³adowa si³y grawitacji prostopad³a do powierzchni stoku:\\
\begin{equation}
F_n = mg\cos\alpha
\end{equation}

Warto¶æ tej si³y wp³ywa na warto¶æ si³y tarcia dzia³aj±cej na narciarza:\\
\begin{equation}
F_f = \mu F_n = \mu mg\cos\alpha
\end{equation}

Oprócz si³y tarcia uwzglêdniamy równie¿ inn± si³ê oporu jak± jest si³a oporu powietrza. Zale¿y ona od prêdko¶ci poruszania siê obiektu. Prêdko¶æ bêdziemy wyra¿aæ jako pierwsz± pochodn± po³o¿enia - $ \dot{x} $:\\
\begin{equation}
F_{d} = k_{1}\dot{x} + k_{2}\dot{x}^2
\end{equation}

Za³o¿enia, które narzucane s± na sta³e $ k_{1} $ oraz $ k_{2} $:\\
\begin{equation}
\left\{ \begin{array}{ll}
 k_{2} = 0  &\mbox{ $v \le B$} \\ 
 k_{1} = 0 &\mbox{ $v \geq  B$} 
\end{array} \right. 
\end{equation}\\
gdzie $ B $:\\
\begin{equation}
B = 4 \frac{m}{s}
\end{equation}

Ograniczenie to zosta³o zaczerpniête z pracy ???? (Aerodynamic-Drag) i opisane w rozdziale ????

Wspó³czynnik $ k_1 $ ....\\
\begin{equation}
k_1 = ... 
\end{equation}

Wspó³czynnik $ k_2 $ zosta³ opisany w ????\\
\begin{equation}
k_2 = \frac{1}{2} C \rho A
\end{equation}

gdzie:\\
$ C $ - wspó³czynnik oporu\\
$ \rho $ - gêsto¶æ powietrza\\
$ A $ - powierzchnia przednia narciarza prostopad³a do kierunku przep³ywu, a zatem prostopad³a do wektora prêdko¶ci narciarza

%---------------------------------------------------------------------------

\section{Numeryczne rozwi±zanie problemu}
\label{sec:numeryczneRozwiazanie}

Rozpatruj±c wszystkie si³y dzia³aj±ce na narciarza równoleg³e do powierzchni stoku, a wiêc powoduj±ce jego ruch w dó³, otrzymujemy nastêpuj±ce równanie:

\begin{equation}
ma=mgsin\alpha-\mu mgcos\alpha-k_{1}\dot{x} - k_{2}\dot{x}^{2}
\end{equation}

Wyra¼my teraz przyspieszenie jako drug± pochodn± po³o¿enia:

\begin{equation}
a = \ddot{x} 
\end{equation}

Podstawiaj±c do równania:

\begin{equation}
m\ddot{x}=mgsin\alpha-\mu mgcos\alpha-k_{1}\dot{x} - k_{2}\dot{x}^{2}
\end{equation}

Zatem po podzieleniu przez m:

\begin{equation}
\label{eq:rownRuchu}
\ddot{x}=gsin\alpha-\mu gcos\alpha-\frac{k_{1}}{m}\dot{x} - \frac{k_{2}}{m}\dot{x}^{2}
\end{equation}

Aby rozwi±zaæ to równanie numerycznie, wprowadzamy now± zmienn± v (odpowiadaj±c± prêdko¶ci):

\begin{equation}
v = \dot{x}
\end{equation}

Otrzymujemy nastêpuj±ce równania:\\
\begin{equation}
\left\{ \begin{array}{ll}
\dot{v} = gsin\alpha-\mu gcos\alpha-\frac{k_{1}}{m}v - \frac{k_{2}}{m}v^{2} \\
v = \dot{x}
\end{array} \right. 
\end{equation}

Pamiêtamy przy tym, ¿e:\\
\begin{equation}
\left\{ \begin{array}{ll}
 k_{2} = 0  &\mbox{ $v \le B$} \\ 
 k_{1} = 0 &\mbox{ $v \geq  B$} 
\end{array} \right. 
\end{equation}

Powy¿szy uk³ad równañ wystarczy wykorzystaæ w dostêpnych w wielu jêzykach funkcjach bibliotecznych do rozwi±zywania równañ ró¿niczkowych zwyczajnych. W naszym przypadku wykorzysta³y¶my funkcjê dopri (Numerical integration of ODE using Dormand-Prince RK method) z biblioteki Numeric Javascript.

\subsection{Rozwi±zanie w 3D}
Powy¿szy uk³ad równañ opisuje poruszanie siê punktu materialnego po równi pochy³ej. Jednak w przypadku narciarza przemieszczaj±cego siê po stoku musimy uwzglêdniæ równie¿ mo¿liwo¶æ poruszania siê w poprzek stoku, a nie tylko w dó³.\\
Za³ó¿my, ¿e narciarz porusza siê tylko po liniach prostych. \\
Rozpatrzmy teraz jak bêdzie wygl±da³ uk³ad si³ dzia³aj±cych na narciarza:\\

% obrazek

Na naszego narciarza dzia³aj± si³y: grawitacji - w kierunku pionowym oraz si³y oporu - w kierunku linii jazdy narciarza. Je¶li rozpatrzymy teraz uk³ad wspó³rzêdnych zorientowany wzglêdem kierunku jazdy, musimy najpierw zrzutowaæ si³ê grawitacji otrzymuj±c si³ê ¶ci±gaj±ca narciarza:

\begin{equation}
g\sin\alpha sinus
\end{equation}

gdzie sinus to:

%-----------------------SINUS-------------------%

Zatem nasze równanie ruchu bêdzie wygl±da³o nastêpuj±co:

\begin{equation}
\ddot{x} = g\sin\alpha*sinus - (\mu F_n + \frac{k_1}{m}\dot{x} + \frac{k_2}{m}\dot{x}^2 )
\end{equation}

gdzie $F_n$ to si³a nacisku narciarza, która pozostaje taka sama jak w przypadku 2D:

\begin{equation}
F_n = gcos\alpha
\end{equation}

Transformuj±c powy¿sze równanie na uk³ad wspó³rzêdnych zorientowany wzd³u¿ i wszerz stoku otrzymamy nastêpuj±ce równania:

% sprawdzic x i y 

\begin{equation}
\left\{ \begin{array}{ll}
\ddot{x_x} = (g*\sin\alpha*sinus - (\mu*F_n + \frac{k_1}{m}\dot{x} + \frac{k_2}{m}\dot{x}^2))*sinus\\
\ddot{x_y} = (g*\sin\alpha*sinus - (\mu*F_n + \frac{k_1}{m}\dot{x} + \frac{k_2}{m}\dot{x}^2))*cosinus
\end{array} \right.
\end{equation}

Po wprowadzeniu jak poprzednio dodatkowych zmiennych, w tym wypadku prêdko¶ci $v_x$ i $v_y$ oraz pamiêtaniu o zale¿no¶ci miêdzy nimi a pochodn± przemieszczenia:

\begin{equation}
\left\{ \begin{array}{ll}
v_x = \dot{x_x}\\
v_y = \dot{x_y}\\
\dot{x} = \sqrt{v_x^2 +v_y^2}
\end{array} \right.
\end{equation}

otrzymujemy:

\begin{equation}
\left\{ \begin{array}{ll}
v_x = \dot{x_x}\\
v_y = \dot{x_y}\\
\dot{v_x} = (g*\sin\alpha*sinus - (\mu*N + \frac{k_1}{m}\dot{x} + \frac{k_2}{m}\dot{x}^2))*sinus\\
\dot{v_y} = (g*\sin\alpha*sinus - (\mu*N + \frac{k_1}{m}\dot{x} + \frac{k_2}{m}\dot{x}^2))*cosinus
\end{array} \right. 
\end{equation}\\


%---------------wzory razem z zakrêtami - gdzie?--------

$$
\left\{\begin{array}{ll} 
  v_x=\dot{x_x} \\
  v_y=\dot{x_y} \\
 \dot{v_x} = gsin\alpha - (\dot{x_x}^2 +\dot{x_y}^2)^{\frac{1}{2}} \kappa \dot{x_y} sgn(\dot{\varphi}) - gsin\alpha \frac{\dot{x_y}^2}{\dot{x_x}^2 +\dot{x_y}^2} - \frac{(F_f + F_d) }{m}\frac{\dot{x_x}}{(\dot{x_x}^2 +\dot{x_y}^2)^{\frac{1}{2}}} \\
 \dot{v_y} = (\dot{x_x}^2 +\dot{x_y}^2)^{\frac{1}{2}} \kappa \dot{x_x} sgn(\dot{\varphi}) + gsin\alpha \frac{\dot{x_x}} {\dot{x_x}^2 +\dot{x_y}^2} - \frac{(F_f + F_d)}{m}\frac{\dot{x_y}}{(\dot{x_x}^2 +\dot{x_y}^2)^{\frac{1}{2}}} 
\end{array}\right.
$$\\
%---------------------------------------------------------------------------

\section{Optymalizacja toru przejazdu}
\label{sec:optymalizacja}
Aby znale¼æ rozwi±zanie problemu, nale¿y przyj±æ jaki¶ sposób reprezentacji ka¿dego z rozwi±zañ. Tor przejazdu narciarza w rzeczywisto¶ci to ¶lad, który pozostawiaj± narty na ¶niegu w trakcie przemieszczania siê po stoku. Jak opisano w rozdziale \ref{sec:matematycznyModel} ????, w celu uproszczenia sposobu przemieszczania siê narciarza, zosta³o zdecydowane, ¿e jako przybli¿enie mo¿na przyj±æ poruszanie siê po ³amanej. Zatem do reprezentacji rozwi±zania mo¿na przyj±æ zbiór punktów, przez które kolejno przeje¿d¿a narciarz, poruszaj±c siê miêdzy tymi punktami wy³±cznie po linii prostej.\\
Jednak wci±¿ takie podej¶cie jest niewystarczaj±ce, poniewa¿ w algorytmach optymalizacyjnych potrzebujemy ¶ci¶lejszego opisu, aby wiedzieæ jak skutecznie przeszukiwaæ przestrzeñ rozwi±zañ. Zatem w zaproponowanym rozwi±zaniu narzucamy z góry co ile metrów w pionie stoku ma pojawiæ siê punkt. Mo¿na traktowaæ to jako poziome linie, z której ka¿da wyznacza mo¿liwe po³o¿enie pojedynczego punktu. Oprócz tego narzucone zosta³o, ¿e narciarz musi przejechaæ jak najbli¿ej ka¿dej wewnêtrznej bramki, co indukuje do³o¿enie punktów w miejscu ka¿dej wewnêtrznej bramki. Warunek ten jest spowodowany tym, ¿e w przeciwnym przypadku algorytm mia³by do przeszukania du¿o wiêcej rozwi±zañ. Opieraj±c siê na do¶wiadczeniu z rzeczywistych slalomów, wiadomo, ¿e przeje¿d¿anie tu¿ przy bramkach jest najkorzystniejsze.
%chyba ¿e do³o¿ymy tê mo¿liwo¶æ, ¿e niektóre mog± byæ albo s± automatycznie wychwytywane. albo ¿e testowane by³o te¿ to jak siê zachowuje je¶li odrzucimy to ograniczenie.

Zatem pozostaje okre¶liæ w jaki sposób mo¿emy stwierdziæ, ¿e dane rozwi±zanie jest najlepsze. W przypadku algorytmów optymalizacyjnych zawsze nale¿y okre¶liæ funkcjê celu. W naszym przypadku interesuje nas, aby narciarz w jak najkrótszym czasie dotar³ do mety. Maj±c dane rozwi±zanie w postaci punktów wyznaczaj±cych ³aman±, obliczamy ile czasu zajmie narciarzowi przejechanie po tej trasie. Im mniejsza warto¶æ tym rozwi±zanie jest lepsze, gdy¿ tym mniej czasu potrzebuje narciarz na prawid³owe pokonanie slalomu.

\subsection{Algorytm ewolucyjny}
\label{sec:ewolucyjnyRozw}
Opisana powy¿ej reprezentacja rozwi±zania to w zastosowanym algorytmie ewolucyjnym pojedynczy osobnik, a punkty sk³adaj±ce siê na to rozwi±zanie, a ¶ci¶lej, ich po³o¿enie w pozycji poziomej okre¶laj± genotyp ka¿dego osobnika. Nie wprowadzamy tu typowego dla algorytmów genetycznych kodowania binarnego, pozycja ka¿dego punktu jest zapamiêtana jako warto¶æ rzeczywista.\\
Dodatkowo do genotypu wchodzi tak¿e parametr $\sigma$, który w strategiach ewolucyjnych u¿ywany jest podczas mutacji tak jak opisano w rozdziale \ref{cha:wstepTeoretyczny} w czê¶ci o strategiach. Ka¿demu punktowi przypisana jest osobna warto¶æ $\sigma$ - odchylenie standardowe.

Zastosowany algorytm opiera siê na strategii ($\mu$ + $\lambda$) opisanej w rozdziale \ref{cha:wstepTeoretyczny}. Jako pocz±tkow± populacjê wybieramy losowe osobniki - poziome warto¶ci punktów s± ograniczone jedynie przez warto¶ci poziome po³o¿enia dwóch najbli¿szych bramek. Jest to kierowane konieczno¶ci± zadbania o szybsze znalezienie rozwi±zania - zbyt du¿e odleg³o¶ci mo¿na z góry odrzuciæ opieraj±c siê na do¶wiadczeniach z rzeczywistej jazdy narciarza po slalomie. Wielko¶æ populacji bazowej $\mu$ jest jednym z parametrów programu, ale najczê¶ciej warto¶æ ta wynosi 30. Warto¶æ parametru $\lambda$ tak¿e jest parametrem, jednak w testach przewa¿nie u¿yto wielko¶ci 100.\\
Szkielet algorytmu zgodny jest z zastosowan± strategi±, po wylosowaniu z istniej±cej populacji populacji tymczasowej o wielko¶ci $\lambda$, dokonuje siê na jej osobnikach operacji genetycznych, najpierw krzy¿owania, a nastêpnie mutacji na osobnikach otrzymanych z krzy¿owania. Kolejnym krokiem jest ocenienie nowych osobników i wybranie spo¶ród nich oraz populacji pocz±tkowej osobników o najlepszym przystosowaniu i to one stanowi± now± populacjê bazow±.

\subsubsection{Krzy¿owanie}
Aby dokonaæ krzy¿owania potrzebne s± pary rodziców dla ka¿dego nowego osobnika. Aby utrzymaæ wielko¶æ populacji tymczasowej, losujemy (ze zwracaniem) $\lambda$ par spo¶ród populacji tymczasowej. Krzy¿owanie rodziców sprowadza siê do obliczenia ¶redniej warto¶ci po³o¿enia odpowiadaj±cych sobie punktów oraz parametrów $\sigma$.

\subsubsection{Mutacja}
Po krzy¿owaniu mamy znowu w populacji tymczasowej $\lambda$ osobników. Mutacja osobników przeprowadzana jest zgodnie ze strategi± - wykorzystywane s± warto¶ci odchyleñ standardowych odpowiadaj±cych kolejnym punktom. Jedynie punkty, które s± przy bramkach nie podlegaj± mutacji. Wynika to z wcze¶niejszego za³o¿enia, ¿e wtedy otrzymamy rozwi±zanie najlepsze.

\subsubsection{Warunek zakoñczenia}
Warunek zakoñczenia algorytmu zawsze sprawia wiele problemów. Nie jest ³atwo zdecydowaæ na jakiej podstawie zatrzymywaæ jego dzia³anie. Czêsto korzysta siê z informacji o rozrzucie przystosowania w populacji - obliczamy go na podstawie ró¿nicy pomiêdzy najlepszym i najgorszym osobnikiem. Je¶li rozrzut ten jest niewielki mo¿e oznaczaæ stagnacjê algorytmu. Niekoniecznie ¶wiadczy to o znalezieniu rozwi±zania, ale w po³±czeniu z dodatkowymi mechanizmami mo¿e byæ skuteczn± metod± na decyzjê o zakoñczeniu optymalizacji.\\
W naszym rozwi±zaniu bierzemy zatem równie¿ pod uwagê taki wska¼nik jak poprawa najlepszego obecnego rozwi±zania. Je¶li przez okre¶lon± liczbê iteracji, najczê¶ciej kilka lub kilkana¶cie najlepsze rozwi±zanie nie poprawia siê w ogóle, a populacja jest bardzo ma³o zró¿nicowana to jest to znak, ¿e znalezione rozwi±zanie powinno byæ wystarczaj±co bliskie najlepszemu. Oczywi¶cie steruj±c liczb± iteracji przez które sprawdzamy zmiany oraz wielko¶ci± rozrzutu populacji mo¿emy znajdowaæ lepsze lub gorsze rozwi±zania kosztem wyd³u¿enia lub skrócenia czasu dzia³ania algorytmu.

\subsection{Hill climbing}
Zastosowanie algorytmu genetycznego sprawdzi³o siê w przypadku problemu narciarza, jednak problemem by³ d³ugi czas wykonywania siê programu. Zw³aszcza s³aba poprawa wyników wystêpowa³a w koñcowej fazie dzia³ania. Widoczne by³y niepotrzebne próby przeszukiwania zbyt odleg³ych rozwi±zañ, a jednak wci±¿ znalezione rozwi±zanie nie by³o tak dobre jak mo¿na by tego oczekiwaæ. Wiedz±c, ¿e rozwi±zanie jest ju¿ dosyæ bliskie najlepszemu mo¿na z du¿ym prawdopodobieñstwem za³o¿yæ, ¿e wystarczy znale¼æ rozwi±zanie lokalnie optymalne, aby by³o ono satysfakcjonuj±ce. Oczywi¶cie nie mamy pewno¶ci, ¿e bêdzie globalnie optymalne, ale takiej pewno¶ci nie mo¿emy mieæ nigdy.\\
Zatem zastosowanie algorytmu lokalnej optymalizacji powinno pomóc w koñcowej fazie poszukiwañ. Z tego powodu u¿yty zosta³ algorytm Hill climbing opisany w rozdziale \ref{cha:wstepTeoretyczny}. W ka¿dym kroku algorytmu sprawdzane jest czy zmiana pojedynczej zmiennej - w tym wypadku poziomej pozycji punktu przejazdu, daje poprawê wyniku. Je¶li zmiany te nie przynosz± rezultatów, s± mniejsze ni¿ narzucony parametr $\epsilon$ algorytm zatrzymuje swoje dzia³anie. Warto¶æ $\epsilon$ wynosi przewa¿nie 0.00001. W przypadku parametrów typowych dla tego algorytmu postanowiono wybraæ warto¶ci: dla przyspieszenia standardowa - 1.2, natomiast dla kroku, mniejsz± ni¿ zwykle, bo wynosz±c± 0.5. Zmiana ta wynika z za³o¿enia, ¿e rozwi±zanie nie powinno potrzebowaæ wiêkszych zmian, aby znale¼æ rozwi±zanie jak najlepsze.
%---------------------------------------------------------------------------

\section{Uczenie maszynowe}
\label{sec:maszynoweRozw}

Oprócz u¿ycia algorytmu genetycznego oraz algorytmu Hill climbing warto by³oby sprawdziæ czy inne podej¶cie do problemu mo¿e dawaæ lepsze rozwi±zanie. Zamiast analizowaæ trasê jako ca³o¶æ, mo¿na spróbowaæ tak jak w rzeczywisto¶ci pozwoliæ narciarzowi decydowaæ o tym jak pojechaæ. Dobry narciarz korzysta z wiedzy o po³o¿eniu dwóch lub trzech kolejnych bramek i na tej podstawie podejmuje decyzjê o torze jazdy. W takim podej¶ciu mo¿na spróbowaæ zastosowaæ uczenie maszynowe.

Je¶li chodzi o reprezentacjê problemu to zachowane zosta³o dotychczasowe za³o¿enie o poziomych liniach wyznaczaj±cych kolejne po³o¿enia w poziomie toru jazdy. Jednak w tym przypadku konieczne jest do³o¿enie równie¿ linii pionowych, a wiêc utworzenie siatki na stoku, której wêz³y wyznaczaj± mo¿liwe punkty tworz±ce tor przejazdu. Wci±¿ obowi±zuje zasada, ¿e kolejne punkty musz± znajdowaæ siê na kolejnych poziomych liniach, tak samo jak konieczno¶æ przejazdu przez punkty, które reprezentuj± bramki. Oczywi¶cie mo¿na powiedzieæ, ¿e takie rozwi±zanie jest mniej dok³adne, ale wszystko zale¿y od gêsto¶ci siatki.

\subsection{Uczenie ze wzmocnieniem}
Za³ó¿my na razie, ¿e nasz narciarz zna po³o¿enie tylko jednej bramki wprzód, a dok³adniej, w ka¿dym kroku wie w jakiej odleg³o¶ci w poziomie i pionie znajduje siê kolejna bramka. Jego zadaniem jest nauczenie siê jak na podstawie tej wiedzy zachowaæ siê, aby jak najszybciej dotrzeæ do celu.\\
Niech slalom sk³ada siê tylko z jednej bramki. Opieraj±c siê na informacjach z rozdzia³u \ref{sec:wzmocnienie}, bardzo ³atwo przedstawiæ nasz problem w postaci uczenia siê ze wzmocnieniem. Narciarz jest uczniem, który poprzez seriê prób i b³êdów, stwierdza jakie zachowanie daje najlepsze efekty. Stanem w naszym ¶rodowisku bêdzie odleg³o¶æ narciarza (w poziomie i pionie) od najbli¿szej bramki. Akcja to wybór zmiany po³o¿enia poziomego na stoku, poruszanie siê w dó³ stoku jest okre¶lone poprzez parametr wej¶ciowy. Po wykonaniu akcji, zmienia siê po³o¿enie narciarza a zatem i jego stan. Poniewa¿ poziome linie wyznaczaj± ile punktów znajdzie siê pomiêdzy ka¿dymi dwiema bramkami, wiêc zawsze, bez wzglêdu na ilo¶æ bramek, dla konkretnego ich u³o¿enia nasze rozwi±zanie bêdzie sk³ada³o siê z okre¶lonej liczby punktów. Widzimy zatem, ¿e nasz algorytm bêdzie polega³ na wielokrotnym powtarzaniu przejazdu slalomu, a ilo¶æ kroków w ka¿dym powtórzeniu bêdzie sta³a. Oznacza to, ¿e naturalnym jest nazwanie tego problemu zadaniem epizodycznym opisanym w rozdziale \ref{subsec:epizodyczne}, jednak nie jest to zadanie do-sukcesu lub do-pora¿ki, gdy¿ narzucone jest, ¿e liczba kroków jest zawsze sta³a w epizodzie. Zatem w ka¿dym epizodzie narciarz musi otrzymywaæ wzmocnienie, które bêdzie wskazywa³o jak dobry jest tor, którym w³a¶nie siê porusza³. Najwa¿niejszy w tej kwestii jest oczywi¶cie czas, w jakim narciarz jest w stanie pokonaæ dany slalom. Zatem nagroda powinna zawsze byæ funkcj± tego czasu. Przyk³adowo, mo¿e byæ to funkcja liniowa: $a-t$, gdzie $a$ to pewna sta³a, a $t$ to czas przejazdu jaki uzyska³ uczeñ. Im krótszy czas, tym wy¿sza nagroda i odwrotnie. Prawid³owe dobranie funkcji nagrody, a tak¿e jej parametrów, tak jak $a$, mo¿e niestety wp³ywaæ na skuteczno¶æ rozwi±zania. Pozosta³e przyk³ady funkcji oraz ich wp³yw na jako¶æ rozwi±zania opisane s± w rozdziale z eksperymentami (\ref{cha:wyniki}). Gdyby slalom sk³ada³ siê z wiêkszej ilo¶ci bramek, nagrodê narciarz otrzyma³by przy ka¿dej bramce, a czas brany do obliczania by³by czasem potrzebnym na przejazd od poprzedniej bramki - w przypadku znajomo¶ci odleg³o¶ci do wiêkszej ilo¶ci bramek, brano by pod uwagê czas przejazdu takiej liczby bramek.

\subsection{Q-learning}
W zastosowanym rozwi±zaniu u¿yty zosta³ algorytm Q-learning opisany w rozdziale \ref{subsec:wzmocnienie}. W algorytmie tym stosowane s± dwa parametry: $\alpha$, $\gamma$, których warto¶æ trzeba dostosowaæ, aby otrzymaæ jak najlepsze rozwi±zanie. Testy przeprowadzone do znalezienia tych warto¶ci s± opisane w rozdziale \ref{cha:wyniki}.

\subsection{Akcja}
Przyjrzyjmy siê dok³adniej akcjom, które podejmowaæ bêdzie narciarz.\\
Za ka¿dym razem otrzymywana jest lista akcji, które mo¿na wykonaæ bêd±c w danym stanie. Aby ograniczyæ liczbê mo¿liwo¶ci, a jednocze¶nie nie odrzucaæ najlepszego rozwi±zania, trzeba by³o zdecydowaæ jakie i ile akcji powinno byæ dostêpnych. Opieraj±c siê na do¶wiadczeniach rzeczywistych, wiadomo ¿e narciarz najczê¶ciej kieruje siê w stronê najbli¿szej bramki i nie wykonuje bardzo gwa³townych skrêtów. Dlatego zak³adaj±c, ¿e bramka jest po prawej stronie, narciarz ma dok³adnie cztery mo¿liwo¶ci: przesun±æ siê o krok w lewo, nie przemieszczaæ siê w poziomie w ogóle, o krok w prawo, lub dwa kroki w prawo. Symetryczna sytuacja jest dla bramki umieszczonej z lewej strony. Oczywi¶cie krok oznacza tu szeroko¶æ narzuconej siatki. W przypadku gêstej siatki, ilo¶æ mo¿liwo¶ci powinna byæ zwiêkszona, jednak zwiêksza to tak¿e z³o¿ono¶æ algorytmu.\\
Z powodu na³o¿enia decyzji o przeje¿d¿aniu przez punkty reprezentuj±ce bramki, bêd±c tu¿ przed bramk±, jedyn± mo¿liwo¶ci± narciarza jest pojechanie prosto do tej bramki - zamiast czterech opcji dostêpna jest tylko jedna, która wymusza przejazd do punktu-bramki.

Kolejn± wa¿n± decyzj± jest wybór sposobu w jaki narciarz decyduje o wybraniu akcji spo¶ród mo¿liwych do wykonania w danym stanie. W wykonanych testach wypróbowane zosta³y dwie mo¿liwo¶ci:

\begin{itemize}
\item strategia zach³anna - wybór pada zawsze na najlepsz± z mo¿liwo¶ci
\item ...
%  TODO  %
\end{itemize}

%paragraf o prêdko¶ci

%---------------------------------------------------------------------------

\section{Architektura systemu}
\label{sec:architektura}

Wybór docelowej architektury dla naszego systemu zosta³ poprzedzony eksperymentowaniem z dwoma ró¿nymi, zgo³a odmiennymi podej¶ciami. Dziêki temu, zosta³y przeanalizowane mocne i s³abe punkty ka¿dej z nich a ostatecznie wybrane rozwi±zanie spe³nia wszystie potrzeby.

\subsection{Architektura prototypowa}

Pierwszym wybranym przez nas ¶rodowiskiem tworzenia systemu by³ jêzyk Python i dostêpne dla niego modu³y: VPython umo¿liwiaj±cy wizualizacjê w 2D i 3D oraz biblioteki numeryczne NumPy i SciPy wykorzystywane do rozwi±zywania równañ ró¿niczkowych. 

Dobrze znany nam jêzyk pozwoli³ nam na szybkie prototypowanie i testowanie pierwszego fizycznego modelu narciarza. Wizualizacja by³a prosta w implementacji, a biblioteki numeryczne wystarczaj±co dobrze udokumentowane i powszechnie u¿ywane, co zapewnia³o ich stabilno¶æ i jako¶æ. Szybko ujawni³y siê jednak wady wybranego ¶rodowiska - uruchomienie naszego programu wymaga³o od u¿ytkownika instalacji z³o¿onego ¶rodowiska do obs³ugi jêzyka Python oraz graficznych i numerycznych bibliotek co by³o istotn± barier±. Bariera ta by³a istotnym problemem, bior±c pod uwagê potencjaln± mo¿liwo¶æ rozpraszania obliczeñ.  Zda³y¶my sobie sprawê, ¿e rozwi±zywany przez nas problem i otrzymywane przez nas wyniki s± atrakcyjne wizualnie i ludzie zwi±zani z narciarstwem z chêci± mog± wzi±æ udzia³ w obliczeniach i udostêpniæ nam zasoby obliczeniowe swoich komputerów. Warunkiem koniecznym by by³o to mo¿liwe jest ³atwo¶æ w do³±czaniu do obliczeñ, wizualizacji wyników i bezproblemowa konfiguracja. Bior±c to pod uwagê, zdecydowa³y¶my ¿e potrzebujemy innego ¶rodowiska.

\subsection{Architektura docelowa}

Potrzeba ³atwo¶ci do³±czania do obliczeñ sk³oni³a nas do stworzenia systemu w którym klientami obliczeniowymi s± przegl±darki internetowe. Klienci chc±cy pod³±czyæ siê do obliczeñ wchodz± na dobrze znany adres internetowy sk±d serwowana jest strona g³ówna i skrypty które dokonuj± obliczeñ. Na ¿±danie klienta, dostaje on ze zdalnego serwisu instancjê problemu, która jest nastêpnie lokalnie przetwarzana i wizualizowana klientowi na bie¿±co. Po skoñczonym obliczeniu, rozwi±zanie jest umieszczane na serwerze a klient mo¿e przej¶æ do obliczania kolejnego problemu, lub jeszcze raz tego samego problemu. 

Architektura naszego systemu sk³ada siê z dwóch g³ównych, niezale¿nych komponentów. Pierwszym jest aplikacja kliencka przeprowadzaj±ca obliczenia i wizualizacjê oraz komunikuj±ca siê z serwerem zarz±dzaj±cym obliczeniami. Drugim jest aplikacja lekkiego serwera http, jako warstwa wystawiaj±ca RESTowe API. Warstw± persystentn± jest dokumentowa, nierelacyjna baza danych CouchDB. 

\subsection{Aplikacja kliencka}

Aplikacja kliencka, to aplikacja webow± stworzon± przy u¿yciu frameworku Chaplin, wprowadzaj±cego dobre praktyki w strukturyzowaniu aplikacji Java Scryptowych opartych na bibliotekê Backbone.js. Aplikacja w ca³o¶ci jest pisana w jêzyku Coffee Script. Coffee Script to przyjazdy w sk³adni jêzyk programowania, kompiluj±cy siê do Java Scriptu. Powsta³y po kompilacji kod Java Script jest czytelny i przyjazny do debugowania. Programuj±c w Coffee Script mo¿na u¿ywaæ wszystkich bibliotek i modu³ów napisanych w Java Script, bo koniec koñców wszystko zamieni siê w Java Script. Zdecydowa³y¶my siê u¿ywaæ tego jêzyka przede wszystkim z uwagi na sk³adnie przypominaj±c± dobrze znany nam jêzyk Python, wiêksz± przejrzysto¶æ i czytelno¶æ kodu. 

Aplikacja ma zasadniczo trzy warstwy:
\begin{itemize}
\item warstwê prezentacyjn± i wizualizacyjn± dla rozwi±zywanego problemu
\item warstwê komunikacji z serwerem
\item warstwê obliczeniow±
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=360px]{diagramClientLayers}
\caption{Sekwencjê komunikacji pomiêdzy poszczególnymi warstwami aplikacji klienckiej}
\label{diagramClientLayers}
\end{figure}

Sekwencjê komunikacji pomiêdzy poszczególnymi warstwami aplikacji klienckiej, przedstawia Diagram \ref{diagramClientLayers} na stronie \pageref{diagramClientLayers}

\subsubsection{Warstwa prezentacji}

Wizualizacja zaimplementowana jest na elemencie Canvas ze specyfikacji HTML5. Wykresy wizualizuj±ce przebieg obliczeñ stworzone s± przy u¿yciu biblioteki Highcharts. Warstwa spe³nia nastêpuj±ce funkcjê:
\begin{itemize}
\item zaznajamiaj±ca u¿ytkownika wchodz±cego na stronê internetow± z tym czemu strona s³u¿y 
\item umo¿liwienie rozpoczêcia wziêcia udzia³u w obliczeniu
\item prezentowanie trasy narciarskiej, popranej z serwera do obliczeñ
\item wizualizacja na bie¿±co wyników obliczeñ w postaci bie¿±co rozwa¿anego toru przejazdu
\item wizualizacja parametrów algorytmu obliczaj±cego w postaci wykresów
\end{itemize}

\subsubsection{Warstwa komunikacyjna}

Komunikacja z serwerem odbywa siê poprzez REST-owe API, wykorzystuj±ce JSONowy format do wymiany danych. Warstwa spe³nia nastêpuj±ce funkcjê:
\begin{itemize}
\item pobieranie instancji problemu do obliczenia 
\item wysy³anie na serwer rozwiazania zadanego problemu
\item pobierania z serwera informacji o obecnie najlepszym rozwi±zaniu tego problemu
\end{itemize}

\subsubsection{Warstwa obliczeniowa}

Zastosowanie w naszej architekturze Web Workerów do wykonywania obliczeñ jest dobrze uzasadnione, bior±c pod uwagê ich specyfikacjê, opisan± szerzej w rozdziale \ref{webWorkers}. Obliczenia trasy przejazdu nawet dla toru z kilkoma bramkami zajmuje co najmniej kilka sekund. Worker na bie¿±co, w trakcie trwania obliczeñ, przekazuje do g³ównego procesu obs³uguj±cego UI strony, kolejne rozwa¿ane trasy. Proces UI rysuje na elemencie Canvas na bie¿±co otrzymywan± trasê.

\subsection{Aplikacja serwerowa}

Aplikacja jest lekkim serwerem Http napisanym w ¶rodowisku Node.js. U¿ytym jêzykiem programowania podobnie jak w aplikacji klienckiej, jest Coffee Script. Serwer wystawia REST-owe API, u¿ywaj±c do wymiany danych JSON-owego formatu serializacji. Serwer komunikuje siê z dokumentow±, nierelacyjn± baz± danych CouchDB. Podstawowymi funkcjami serwera s±:

\begin{itemize}
\item umo¿liwienie dodania instancji problemu obliczeniowego do bazy danych
\item zwracanie na ¿±danie problemu obliczeniowego do rozwi±zania 
\item zwracania informacji o obecnych dostêpnych rozwi±zaniach ka¿dego z problemów obliczeniowych
\end{itemize} 

\begin{figure}[h]
\centering
\includegraphics[width=360px]{diagramClientServerDb}
\caption{Sekwencja komunikacji pomiêdzy poszczególnymi komponentami systemu oraz warstw± persystencji}
\label{diagramClientServerDb}
\end{figure}

Diagram \ref{diagramClientServerDb} na stronie \pageref{diagramClientServerDb} pokazuje sekwencjê komunikacji pomiêdzy komponentami systemu oraz warstw± persystencji.

\subsection{Efekt koñcowy}

Efektem widocznym dla koñcowego u¿ytkownika powsta³ej na potrzeby tego projektu aplikacji jest strona www, dostêpna pod dobrze znanym adresem URL - http://giant-client.herokuapp.com/. Na stronie jest krótko wyt³umaczone o co chodzi w projekcie i w jaki sposób ka¿dy odwiedzaj±cy mo¿e pomóc w obliczeniach. Na stronie znajduje siê jedno wyra¼ne tzn. "call to action" - du¿y przycisk zachêcaj±cy do rozpoczêcia obliczeñ.


\begin{figure}[h]
\centering
\includegraphics[width=400px]{interfejs-1}
\caption{Nasza strona zachêcaj±c± do uruchomienia obliczeñ}
\label{fig:interfejs-1}
\end{figure}

Po uruchomieniu obliczeñ, osoba odwiedzaj±ca stronê dostaje na bie¿±co informacje zwrotne dotycz±ce efektów jej wspó³pracy. Na stronie:

\begin{itemize}
\item rysowana jest ca³y czas aktualnie rozwa¿ana trasa przejazdu
\item wy¶wietla siê obliczony czas przejazdu po aktualnie rozwa¿anym torze przejazdu
\item wy¶wietla siê najlepszy, dotychczas znaleziony, czas przejazdu dla aktualnie rozwa¿anej konfiguracji trasy
\item rysowane s± wykresy przedstawiaj±ce parametry algorytmu genetycznego (aktualny Fitness populacji) 
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=400px]{interfejs-2}
\caption{Nasza strona, podczas prowadzonych obliczeñ}
\label{fig:interfejs-2}
\end{figure}
