\chapter{Architektura systemu}
\label{sec:architektura}

Wybór docelowej architektury dla naszego systemu zosta³ poprzedzony eksperymentowaniem z dwoma ró¿nymi, zgo³a odmiennymi podej¶ciami. Dziêki temu, zosta³y przeanalizowane mocne i s³abe punkty ka¿dej z nich, a ostatecznie wybrane rozwi±zanie spe³nia wszystkie potrzeby.

\section{Architektura prototypowa}
\label{sec:arch-prototypowa}

Pierwszym wybranym przez nas ¶rodowiskiem tworzenia systemu by³ jêzyk Python i dostêpne dla niego modu³y: VPython umo¿liwiaj±cy wizualizacjê w 2D i 3D oraz biblioteki numeryczne NumPy i SciPy wykorzystywane do rozwi±zywania równañ ró¿niczkowych. 

Dobrze znany nam jêzyk pozwoli³ nam na szybkie prototypowanie i testowanie pierwszego fizycznego modelu narciarza. Wizualizacja by³a prosta w implementacji, a biblioteki numeryczne wystarczaj±co dobrze udokumentowane i powszechnie u¿ywane, co zapewnia³o ich stabilno¶æ i jako¶æ. Szybko ujawni³y siê jednak wady wybranego ¶rodowiska - uruchomienie naszego programu wymaga³o od u¿ytkownika instalacji z³o¿onego ¶rodowiska do obs³ugi jêzyka Python oraz graficznych i numerycznych bibliotek, co by³o istotn± barier±. Stanowi³o to powa¿ny problem, bior±c pod uwagê potencjaln± mo¿liwo¶æ rozpraszania obliczeñ. Zda³y¶my sobie sprawê, ¿e rozwi±zywany przez nas problem i otrzymywane przez nas wyniki s± atrakcyjne wizualnie i ludzie zwi±zani z narciarstwem z chêci± mog± wzi±æ udzia³ w obliczeniach i udostêpniæ nam zasoby obliczeniowe swoich komputerów. Wiedzia³y¶my, ¿e warunkiem koniecznym by zrealizowaæ tê wizjê jest ³atwo¶æ w do³±czaniu do obliczeñ, wizualizacji wyników i bezproblemowa konfiguracja. Bior±c to pod uwagê, zdecydowa³y¶my, ¿e potrzebujemy innego ¶rodowiska.

\section{Architektura docelowa}

Potrzeba ³atwo¶ci do³±czania do obliczeñ sk³oni³a nas do stworzenia systemu, w którym klientami obliczeniowymi s± przegl±darki internetowe. Klienci chc±cy pod³±czyæ siê do obliczeñ wchodz± na dobrze znany adres internetowy sk±d serwowana jest strona g³ówna i skrypty, które dokonuj± obliczeñ. Na ¿±danie klienta, dostaje on ze zdalnego serwisu egzemplarz problemu, który jest nastêpnie lokalnie przetwarzany i wizualizowany klientowi na bie¿±co. Po skoñczonym obliczeniu, rozwi±zanie jest umieszczane na serwerze, a klient mo¿e przej¶æ do obliczania kolejnego lub jeszcze raz tego samego problemu.

Architektura naszego systemu sk³ada siê z dwóch g³ównych, niezale¿nych czê¶ci sk³adowych. Pierwsz± z czê¶ci jest aplikacja kliencka przeprowadzaj±ca obliczenia i wizualizacjê oraz komunikuj±ca siê z serwerem zarz±dzaj±cym obliczeniami. Drugim jest aplikacja \textit{lekkiego} serwera http, jako warstwa wystawiaj±ca REST API. Warstw± persystentn± jest dokumentowa, nierelacyjna baza danych CouchDB. Schemat architektury prezentuje rysunek \ref{fig:architektureSimple}.

\begin{figure}[H]
\centering
\includegraphics[width=360px]{architekture-simple}
\caption{Uproszczony schemat architektury docelowej}
\label{fig:architektureSimple}
\end{figure}


\paragraph{Aplikacja kliencka}

Aplikacja kliencka to aplikacja webowa stworzona przy u¿yciu frameworku Chaplin, wprowadzaj±cego dobre praktyki w strukturyzowaniu aplikacji Java Script'owych wykorzystuj±cych bibliotekê Backbone.js. Aplikacja w ca³o¶ci napisana jest w jêzyku Coffee Script. Jest to jêzyk programowania ze sk³adni± podobn± do sk³adni Python'a, kompiluj±cy siê do Java Script'u. Powsta³y po kompilacji kod Java Script jest czytelny i przyjazny do debugowania. Programuj±c w Coffee Script mo¿na u¿ywaæ wszystkich bibliotek i modu³ów napisanych w Java Script, co daje wiele mo¿liwo¶ci z powodu szerokiego zakresu dostêpnych bibliotek w tym jêzyku. Zdecydowa³y¶my siê u¿ywaæ tego jêzyka przede wszystkim z uwagi na sk³adniê przypominaj±c± dobrze znany nam jêzyk Python, wiêksz± przejrzysto¶æ i czytelno¶æ kodu ni¿ Java Script, jednocze¶nie zachowuj±c szerokie mo¿liwo¶ci tego jêzyka.

Aplikacja ma zasadniczo trzy warstwy:
\begin{itemize}
\item warstwê prezentacyjn± i wizualizacyjn± dla rozwi±zywanego problemu,
\item warstwê komunikacji z serwerem,
\item warstwê obliczeniow±.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=360px]{diagramClientLayers}
\caption{Uproszczony diagram sekwencji pomiêdzy poszczególnymi warstwami aplikacji klienckiej. Warstwa obliczeniowa przekazuje do warstwy prezentacji wiele tymczasowych rozwi±zañ oraz, po zakoñczeniu pe³nego cyklu obliczeñ, finalne, najlepsze rozwi±zanie, które nastêpnie przekazywane jest na serwer.}
\label{diagramClientLayers}
\end{figure}

Komunikacje pomiêdzy poszczególnymi warstwami aplikacji klienckiej w postaci diagramu sekwencji przedstawia Diagram \ref{diagramClientLayers} na stronie \pageref{diagramClientLayers}.

\subsubsection{Warstwa prezentacji}

Wizualizacja zaimplementowana jest na elemencie Canvas ze specyfikacji HTML5. Wykresy wizualizuj±ce przebieg obliczeñ stworzone s± przy u¿yciu biblioteki Highcharts. Warstwa spe³nia nastêpuj±ce funkcje:
\begin{itemize}
\item wyja¶nienie u¿ytkownikowi jaki problem jest rozwi±zywany oraz jak mo¿e pomóc,
\item umo¿liwienie rozpoczêcia wziêcia udzia³u w obliczeniu,
\item prezentowanie trasy narciarskiej (uk³adu bramek), pobranej z serwera do obliczeñ,
\item wizualizacja na bie¿±co wyników obliczeñ w postaci rozwa¿anego jako najlepszy toru przejazdu,
\item wizualizacja statystyk algorytmu obliczaj±cego w postaci wykresów.
\end{itemize}

\subsubsection{Warstwa komunikacyjna}

Komunikacja z serwerem odbywa siê poprzez REST-owe API, wykorzystuj±ce JSON-owy format do wymiany danych. Warstwa spe³nia nastêpuj±ce funkcje:
\begin{itemize}
\item pobieranie instancji problemu do obliczenia,
\item wysy³anie na serwer rozwi±zania zadanego problemu,
\item pobierania z serwera informacji o obecnie najlepszym rozwi±zaniu tego problemu.
\end{itemize}

\subsubsection{Warstwa obliczeniowa}

Zastosowanie w naszej architekturze Web Worker'ów do wykonywania obliczeñ jest dobrze uzasadnione, bior±c pod uwagê ich specyfikacjê, opisan± szerzej w rozdziale \ref{webWorkers}. Obliczenia trasy przejazdu nawet dla toru z kilkoma bramkami zajmuje co najmniej kilka sekund. Worker na bie¿±co, w trakcie trwania obliczeñ, przekazuje do g³ównego procesu obs³uguj±cego UI strony, kolejne rozwa¿ane trasy. Proces UI rysuje na elemencie Canvas na bie¿±co otrzymywan± trasê.

\paragraph{Aplikacja serwerowa}

Aplikacja jest lekkim serwerem Http napisanym w ¶rodowisku Node.js. U¿ytym jêzykiem programowania, podobnie jak w aplikacji klienckiej, jest Coffee Script. Serwer wystawia REST-owe API, u¿ywaj±c do wymiany danych JSON-owego formatu serializacji. Serwer komunikuje siê z dokumentow± baz± danych CouchDB. Podstawowymi funkcjami serwera s±:

\begin{itemize}
\item umo¿liwienie dodania instancji problemu obliczeniowego do bazy danych,
\item zwracanie na ¿±danie problemu obliczeniowego do rozwi±zania,
\item zwracania informacji o obecnych dostêpnych rozwi±zaniach ka¿dego z problemów obliczeniowych.
\end{itemize} 

\begin{figure}[h]
\centering
\includegraphics[width=360px]{diagramClientServerDb}
\caption{Uproszczony diagram sekwencji pomiêdzy poszczególnymi komponentami systemu oraz warstw± persystencji}
\label{diagramClientServerDb}
\end{figure}

Diagram \ref{diagramClientServerDb} na stronie \pageref{diagramClientServerDb} pokazuje sekwencjê komunikacji pomiêdzy komponentami systemu oraz warstw± persystencji.

\paragraph{Interfejs systemu udostêpniony u¿ytkownikowi}

Efektem widocznym dla koñcowego u¿ytkownika powsta³ej na potrzeby tej pracy aplikacji jest strona www, dostêpna pod adresem URL - \textit{http://giant-client.herokuapp.com/}. Na stronie, poza krótkim wyt³umaczeniem celu projektu i sposobu w jaki ka¿dy odwiedzaj±cy mo¿e pomóc w obliczeniach, znajduje siê jedno wyra¼ne tzw. ``call to action'' - du¿y przycisk zachêcaj±cy do rozpoczêcia obliczeñ.

\begin{figure}[h]
\centering
\includegraphics[width=400px]{interfejs-1}
\caption{Strona g³ówna zachêcaj±c± do uruchomienia obliczeñ}
\label{fig:interfejs-1}
\end{figure}

Po uruchomieniu obliczeñ osoba odwiedzaj±ca stronê dostaje na bie¿±co informacje zwrotne dotycz±ce efektów jej wspó³pracy. Na stronie:

\begin{itemize}
\item rysowana jest ca³y czas aktualnie rozwa¿ana jako najlepsza trasa przejazdu,
\item wy¶wietla siê obliczony czas przejazdu po aktualnie rozwa¿anym torze przejazdu,
\item wy¶wietla siê najlepszy, dotychczas znaleziony, czas przejazdu dla aktualnie rozwa¿anej konfiguracji trasy,
\item rysowane s± wykresy przedstawiaj±ce statystyki algorytmu ewolucyjnego (aktualny Fitness populacji - najlepszy, najgorszy oraz ¶rednia dla wszystkich osobników).
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=500px]{interfejs-2}
\caption{Aplikacja w trakcie prowadzenia obliczeñ}
\label{fig:interfejs-2}
\end{figure}

